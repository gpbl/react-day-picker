import { useContext } from "react";
import type {
  Dispatch,
  KeyboardEvent,
  MouseEvent,
  SetStateAction
} from "react";

import { differenceInCalendarDays } from "date-fns/differenceInCalendarDays";
import { isSameDay } from "date-fns/isSameDay";

import type {
  Mode,
  DayModifiers,
  DateRange,
  SingleRequiredSelectHandler,
  SingleSelectHandler,
  MultiRequiredSelectHandler,
  MultiSelectHandler,
  RangeRequiredOnSelect,
  RangeSelectHandler,
  Selected
} from "../types";
import { addToRange } from "../utils/addToRange";
import { isDateInRange } from "../utils/isDateInRange";

import { SelectionContext } from "./selection";
import { UseProps, useProps } from "./useProps";

export type UseSelection<
  ModeType extends Mode,
  IsRequired extends boolean = false
> = {
  selected: ModeType extends Mode ? Selected<ModeType, IsRequired> : undefined;
  isSelected: (date: Date) => boolean;
  setSelected: (
    date: Date,
    modifiers: DayModifiers,
    e: MouseEvent | KeyboardEvent
  ) => void;
} & (ModeType extends "range"
  ? {
      /**
       * In range selection mode, return `true` if the given day is the start of
       * the range.
       */
      isStartOfRange: (date: Date) => boolean;
      /**
       * In range selection mode, return `true` if the given day is the end of
       * the range.
       */
      isEndOfRange: (date: Date) => boolean;
      /**
       * In range selection mode, return `true` if the given day is in the
       * middle of the range.
       */
      isMiddleOfRange: (date: Date) => boolean;
    }
  : // eslint-disable-next-line @typescript-eslint/ban-types
    {});

type SelectionResult<
  ModeType,
  IsRequired extends boolean = false
> = ModeType extends Mode ? UseSelection<ModeType, IsRequired> : undefined;

/**
 * Access and change the currently selected values.
 *
 * Use this hook from the custom components passed via the `components` prop.
 *
 * @template ModeType - The selection mode.
 * @template IsRequired - Whether the selection is required.
 * @group Hooks
 * @see https://react-day-picker.js.org/advanced-guides/custom-components
 */

export function useSelection<
  ModeType extends Mode | undefined,
  IsRequired extends boolean = false
>(
  mode: ModeType,
  required?: IsRequired
): SelectionResult<ModeType, IsRequired> {
  const context = useContext(SelectionContext);
  const props = useProps<ModeType, IsRequired>();

  if (!mode) {
    return undefined as SelectionResult<ModeType, IsRequired>;
  }

  if (!context) {
    throw new Error(`useSelection must be used within a SelectionProvider.`);
  }
  const [value, setValue] = context;

  const singleProps = props as UseProps<"single", IsRequired>;
  const multiProps = props as UseProps<"multiple", IsRequired>;
  const rangeProps = props as UseProps<"range", IsRequired>;

  let isSelected: (date: Date) => boolean;
  switch (props.mode) {
    case "single":
      isSelected = props.required
        ? (date: Date) => isSameDay(value as Date, date)
        : (date: Date) => value && isSameDay(value as Date, date);
      break;
    case "multiple":
      isSelected = props.required
        ? (date: Date) => (value as Date[]).some((d) => isSameDay(d, date))
        : (date: Date) =>
            value && (value as Date[]).some((d) => isSameDay(d, date));
      break;
    case "range":
      isSelected = props.required
        ? (date: Date) => isDateInRange(date, value as DateRange)
        : (date: Date) => value && isDateInRange(date, value as DateRange);
      break;
    default:
      throw new Error(`Invalid mode: ${props.mode}`);
  }

  const handleSingleRequired = (
    triggerDate: Date,
    modifiers: DayModifiers,
    setValue: (date: Date) => void,
    e: MouseEvent | KeyboardEvent
  ) => {
    setValue(triggerDate);
    (singleProps.onSelect as SingleRequiredSelectHandler)?.(
      triggerDate,
      triggerDate,
      modifiers,
      e
    );
  };

  const handleSingleOptional = (
    triggerDate: Date,
    modifiers: DayModifiers,
    setValue: Dispatch<SetStateAction<Date | undefined>>,
    e: MouseEvent | KeyboardEvent
  ) => {
    const newValue = modifiers.selected ? undefined : triggerDate;
    setValue(newValue);
    (singleProps.onSelect as SingleSelectHandler)?.(
      newValue,
      triggerDate,
      modifiers,
      e
    );
  };

  const handleMultipleRequired = (
    triggerDate: Date,
    modifiers: DayModifiers,
    setValue: Dispatch<SetStateAction<Date[]>>,
    value: Date[],
    e: MouseEvent | KeyboardEvent
  ) => {
    let newValue;
    if (modifiers.selected) {
      if (value.length === 1 || value.length === multiProps.min) {
        // min reached - cannot remove date
        newValue = [triggerDate];
      } else {
        // remove the date
        newValue = value.filter((d) => !isSameDay(d, triggerDate));
      }
    } else if (value?.length === multiProps.max) {
      // Max value reached, reset the selection to date
      newValue = [triggerDate];
    } else {
      // Add the date to the selection
      newValue = [...value, triggerDate];
    }
    setValue(newValue);
    (multiProps.onSelect as MultiRequiredSelectHandler)?.(
      newValue,
      triggerDate,
      modifiers,
      e
    );
  };

  const handleMultipleOptional = (
    triggerDate: Date,
    modifiers: DayModifiers,
    setValue: Dispatch<SetStateAction<Date[] | undefined>>,
    value: Date[] | undefined,
    e: MouseEvent | KeyboardEvent
  ) => {
    let newValue: Date[] | undefined;
    if (modifiers.selected && value) {
      if (value.length === 1 || value.length === multiProps.min) {
        // min reached - reset the selection
        newValue = undefined;
      } else {
        // remove the date
        newValue = value.filter((d) => !isSameDay(d, triggerDate));
      }
    } else if (value?.length === multiProps.max) {
      // Max value reached, reset the selection to date
      newValue = [triggerDate];
    } else if (value) {
      // Add the date to the selection
      newValue = [...value, triggerDate];
    } else {
      // Set a new selection
      newValue = [triggerDate];
    }
    setValue(newValue);
    (multiProps.onSelect as MultiSelectHandler)?.(
      newValue,
      triggerDate,
      modifiers,
      e
    );
  };

  const handleRangeRequired = (
    triggerDate: Date,
    modifiers: DayModifiers,
    setValue: Dispatch<SetStateAction<DateRange>>,
    value: DateRange,
    e: MouseEvent | KeyboardEvent
  ) => {
    const newValue = addToRange(triggerDate, value);
    if (rangeProps.min) {
      if (
        newValue.from &&
        newValue.to &&
        differenceInCalendarDays(newValue.to, newValue.from) <= min
      ) {
        newValue.from = triggerDate;
        newValue.to = undefined;
      }
    }
    if (rangeProps.max) {
      if (
        newValue.from &&
        newValue.to &&
        differenceInCalendarDays(newValue.to, newValue.from) + 1 > max
      ) {
        newValue.from = triggerDate;
        newValue.to = undefined;
      }
    }
    setValue(newValue);
    (rangeProps.onSelect as RangeRequiredOnSelect)?.(
      newValue,
      triggerDate,
      modifiers,
      e
    );
  };

  const handleRangeOptional = (
    triggerDate: Date,
    modifiers: DayModifiers,
    setValue: Dispatch<SetStateAction<DateRange | undefined>>,
    value: DateRange | undefined,
    e: MouseEvent | KeyboardEvent
  ) => {
    const newRange = addToRange(triggerDate, value);
    if (rangeProps.min) {
      if (
        newRange.from &&
        newRange.to &&
        differenceInCalendarDays(newRange.to, newRange.from) <= min
      ) {
        newRange.from = triggerDate;
        newRange.to = undefined;
      }
    }
    if (rangeProps.max) {
      if (
        newRange.from &&
        newRange.to &&
        differenceInCalendarDays(newRange.to, newRange.from) + 1 > max
      ) {
        newRange.from = triggerDate;
        newRange.to = undefined;
      }
    }
    let newValue: DateRange | undefined = newRange;
    if (!newRange.from && !newRange.to) {
      newValue = undefined;
    }
    setValue(newValue);
    (rangeProps.onSelect as RangeSelectHandler)?.(
      newValue,
      triggerDate,
      modifiers,
      e
    );
  };

  const setSelected = (
    date: Date,
    modifiers: DayModifiers,
    e: MouseEvent | KeyboardEvent
  ) => {
    switch (props.mode) {
      case "single":
        if (props.required) {
          handleSingleRequired(
            date,
            modifiers,
            setValue as Dispatch<SetStateAction<Date>>,
            e
          );
        } else {
          handleSingleOptional(
            date,
            modifiers,
            setValue as Dispatch<SetStateAction<Date | undefined>>,
            e
          );
        }
        break;
      case "multiple":
        if (props.required) {
          handleMultipleRequired(
            date,
            modifiers,
            setValue as Dispatch<SetStateAction<Date[]>>,
            value as Date[],
            e
          );
        } else {
          handleMultipleOptional(
            date as Date,
            modifiers,
            setValue as Dispatch<SetStateAction<Date[] | undefined>>,
            value as Date[] | undefined,
            e
          );
        }
        break;
      case "range":
        if (props.required) {
          handleRangeRequired(
            date as Date,
            modifiers,
            setValue as Dispatch<SetStateAction<DateRange>>,
            value as DateRange,
            e
          );
        } else {
          handleRangeOptional(
            date as Date,
            modifiers,
            setValue as Dispatch<SetStateAction<DateRange | undefined>>,
            value as DateRange | undefined,
            e
          );
        }
        break;
    }
  };

  switch (props.mode) {
    case "single": {
      return {
        selected: value,
        setSelected,
        isSelected
      } as SelectionResult<"single", IsRequired>;
    }
    case "multiple": {
      return {
        selected: value,
        setSelected,
        isSelected
      } as SelectionResult<"multiple", IsRequired>;
    }
    case "range": {
      const range = value as DateRange | undefined;
      const isStartOfRange = (date: Date) => {
        if (!range) return false;
        if (!range.from) return false;
        return isSameDay(date, range.from);
      };
      const isEndOfRange = (date: Date) => {
        if (!range) return false;
        if (!range.to) return false;
        return isSameDay(date, range.to);
      };
      const isMiddleOfRange = (date: Date) => {
        if (!range) return false;
        return (
          !isStartOfRange(date) &&
          !isEndOfRange(date) &&
          isDateInRange(date, range)
        );
      };
      return {
        selected: value,
        isSelected,
        setSelected,
        isStartOfRange,
        isEndOfRange,
        isMiddleOfRange
      } as SelectionResult<"range", IsRequired>;
    }
    default:
      throw new Error(`Invalid mode: ${props.mode}`);
  }
}
